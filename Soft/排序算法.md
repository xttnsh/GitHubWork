## 一. 冒泡排序(BubbleSort)

------

- **基本思想：**两个数比较大小，较大的数下沉，较小的数冒起来。
- **过程：**
  - 比较相邻的两个数据，如果第二个数小，就交换位置。
  - 从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。
  - 继续重复上述过程，依次将第2.3...n-1个最小数排好位置。
- **平均时间复杂度：**O(n2)

## 二. 选择排序(SelctionSort)

------

- **基本思想：**
  在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
  第二次遍历n-2个数，找到最小的数值与第二个元素交换；
  。。。
  第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。
- **平均时间复杂度：**O(n2)

## 三. 插入排序(Insertion Sort)

------

- **基本思想：**
  在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
- **平均时间复杂度：**O(n2)

## 四. 希尔排序(Shell Sort)

------

- **基本思想：**
  希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

  希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

  它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。    

  在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。
  然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。

- **平均时间复杂度：**O(n1.3)

## 五. 快速排序(Quicksort)

------

- **基本思想：（分治）**

  - 先从数列中取出一个数作为key值；
  - 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
  - 对左右两个小数列重复第二步，直至各区间只有1个数。

- **辅助理解：**

  - 初始时 i = 0; j = 9; key=72

    由于已经将a[0]中的数保存到key中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。

    从j开始向前找一个比key小的数。当j=8，符合条件，

    a[0] = a[8] ; i++ ;

     

    将a[8]挖出再填到上一个坑a[0]中。

    这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。

    这次从i开始向后找一个大于key的数，当i=3，符合条件，

    a[8] = a[3] ; j-- ;

     

    将a[3]挖出再填到上一个坑中。

    ```
    数组：72 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 48 - 85
     0   1   2    3    4    5    6    7    8    9
    ```

  - 此时 i = 3; j = 7; key=72

    再重复上面的步骤，先从后向前找，再从前向后找。

    从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，

    a[3] = a[5]; i++;

    从i开始向后找，当i=5时，由于i==j退出。

    此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将key填入a[5]。

    ```
    数组：48 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 88 - 85
     0   1   2    3    4    5    6    7    8    9
    ```

  - 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。

    ```
    <数组：48 - 6 - 57 - 42 - 60 - 72 - 83 - 73 - 88 - 85
     0   1   2    3    4    5    6    7    8    9
    ```

- **平均时间复杂度：**O(N*logN)

- **代码实现：**